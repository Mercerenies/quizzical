
import { Question } from '../question.js';
import { LuaBridge } from '../lua/bridge.js';

/**
 * A QuestionFactory provides an interface to build a question from a
 * Lua data structure.
 */
export interface QuestionFactory<T extends Question> {

  /**
   * The type name for the question. Usually, this is the name of the
   * class which will be generated by the builder. This must match the
   * type field on the Lua data structure.
   */
  readonly name: string;

  /**
   * create() takes a LuaBridge and produces a question. When create()
   * is called, the LuaBridge will contain at least one value on its
   * stack. The top value of the Lua stack shall be a data structure
   * which is meant to be interpreted as a question.
   *
   * In the case of normal execution, create() shall leave the Lua
   * stack exactly the way it was found, including leaving the
   * question value on top of the stack. If an exception is thrown,
   * the stack may be left in an unspecified state.
   */
  create(bridge: LuaBridge): T;

}

/**
 * A collection of QuestionFactorys on which a Lua value can be dispatched.
 */
export class QuestionFactoryDispatcher<T extends Question> {
  private map: Map<string, QuestionFactory<T>> = new Map();

  get(name: string): QuestionFactory<T> | undefined {
    return this.map.get(name);
  }

  /**
   * create() takes a LuaBridge and produces a question. The top value
   * of the LuaBridge should be a value to be interpreted as a
   * question at the time of calling. This function will always leave
   * the Lua stack exactly as it was found, even in the case of
   * exceptions.
   *
   * Note that callers should be prepared to handle exceptions, as any
   * error in the data (including an invalid type field) will result
   * in a Javascript exception being raised.
   */
  create(bridge: LuaBridge): T {
    return bridge.preserveStackSize(() => {
      const ebp = bridge.getTop() - 1;

      bridge.getField(ebp + 1, "type");
      const typeField = bridge.toStringPrim(-1);
      bridge.pop(1);

      const factory = this.get(typeField);
      if (factory === undefined) {
        if (typeField == "") {
          throw `Invalid question type ${typeField} (does the type field exist on the question?)`;
        } else {
          throw `Invalid question type ${typeField}`;
        }
      }

      return factory.create(bridge);
    });
  }

  register(factory: QuestionFactory<T>): void {
    if (this.map.has(factory.name)) {
      throw `QuestionFactoryDispatcher already has a factory for ${factory.name}`;
    }
    this.map.set(factory.name, factory);
  }

  unregister(name: string): void {
    this.map.delete(name);
  }

}
